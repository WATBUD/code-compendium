### 什麼是 Server-Side Rendering (SSR)？
一種網頁渲染技術，將網頁內容在伺服器端完成渲染後，再將完整的 HTML 發送給客戶端。
與傳統的 Client-Side Rendering (CSR) 形成對比，後者是客戶端通過 JavaScript 動態生成內容。

### **CSR（Client-Side Rendering，客戶端渲染）**
- **特點**：需要先下載並執行 JavaScript 才能渲染內容，初次渲染速度較慢。
- **適用場景**：適合互動性強、內容動態變化的應用（如 SPA 單頁應用）。
- **缺點**：初次渲染較慢對 SEO 不友好，搜索引擎爬蟲無法正確解析 JavaScript 生成的內容。

### **SSR（Server-Side Rendering，伺服器端渲染）**
- **特點**：初次渲染快=>伺服器預生成 HTML返回給瀏覽器。
- **適用場景**：適合需要 SEO 的網站（如新聞網站、電商平台等）。
- **流程**：
  1. 瀏覽器發送請求。
  2. 伺服器生成 HTML。
  3. 伺服器返回 HTML 給瀏覽器。
  4. 瀏覽器渲染頁面並執行 JavaScript 進行「水合（Hydration）」。
- **優點**：
  - 提升初次渲染速度，改善用戶體驗。
  - 對 SEO 友好，因為搜索引擎可以直接抓取預渲染的 HTML 內容。
- **缺點**：
  - 需要額外的伺服器資源來生成 HTML。
  - 水合過程可能導致頁面互動性延遲。

### **SSG（Static Site Generation，靜態生成）**
- **特點**：構建時生成靜態 HTML 頁面直接提供給瀏覽器，加載速度極快，但無法處理動態內容。
- **適用場景**：適合內容穩定較少變動的網站（如部落格、文件網站等）。
- **優點**：
  - 極快的加載速度，因為頁面是預先生成的。
  - 對 SEO 友好。
- **缺點**：
  - 不適合內容頻繁更新的網站。

### **ISR（Incremental Static Regeneration，增量靜態再生成）**
- **特點**：在 SSG 的基礎上結合 SSG 和動態更新，允許定期或按需重新生成靜態頁面。
- **流程**：
  1. 首次請求時，返回預先生成的靜態頁面。
  2. 在背景中定期檢查內容是否需要更新，並重新生成頁面。
- **適用場景**：適合內容需要定期更新，但不需要即時更新的網站。
- **優點**：
  - 結合了 SSG 的速度優勢和動態更新的靈活性。
  - 對 SEO 友好。
- **缺點**：
  - 需要額外的配置來管理更新頻率。

### **Hydration（水合）**
- **定義**：將伺服器渲染的靜態 HTML 與客戶端的 JavaScript 邏輯結合，使頁面具有互動性。
- **流程**：
  1. 伺服器返回預渲染的 HTML。
  2. 瀏覽器加載 JavaScript。
  3. JavaScript 接管靜態 HTML，並綁定事件處理程序等互動邏輯。
- **優點**：
  - 提升初次渲染速度，改善用戶體驗。
  - 對 SEO 友好，因為搜索引擎可以直接抓取預渲染的 HTML 內容。
- **缺點**：
  - 需要額外的伺服器資源來生成 HTML。
  - 水合過程可能導致頁面互動性延遲，尤其是在 JavaScript 文件較大時。

### 1. **傳統 C# 服務器端渲染（SSR）**

[瀏覽器請求] → [接收 HTML] → [直接看到內容] ↓ [下載 CSS/圖片等資源]

### 特點：
- **同步渲染**：瀏覽器接收到完整的 HTML 後，立即展示內容。
- **簡單直接**：沒有額外的 JavaScript 操作，適合靜態網站和內容不頻繁變動的網站。
- **較慢的首次加載時間**：每次請求都需要重新渲染頁面，增加服務器負擔。

### 2. **現代 SSR (Next.js/Nuxt.js)**
步驟 1: 瀏覽器收到 HTML
   [<button>點擊次數：0</button>]  <- 用戶已經看到內容，但按鈕不能點

步驟 2: JavaScript 下載完成，開始 Hydration
   - React/Vue 讀取 DOM 比對虛擬 DOM
   - 添加事件監聽器
   - 設置內部狀態

步驟 3: Hydration 完成
   [<button onClick={...}>點擊次數：0</button>]  <- 按鈕現在可以點擊了

* 首屏渲染CSS還沒載入畫面會不完整怎麼辦?:
* 提前加載：預載 CSS 會在 HTML 解析時立刻請求，這樣可以提前開始下載，減少等待時間。
<link rel="preload" href="styles.css" as="style">

```
時間軸：
[瀏覽器請求] → [接收 HTML+ 預渲染內容] → [渲染預渲染內容] → [下載 JS/CSS/圖片等資源] 
→ [Hydration(加載 JavaScript 並啟動 SPA 功能)] → [頁面變得可互動]
```

### 3. **CSR (Client-Side Rendering) **
時間軸：
[瀏覽器請求] → [接收 HTML 框架] → [下載 JS/CSS/圖片等資源] → [JavaScript 渲染內容] → [頁面變得可互動]

初始 HTML（幾乎是空的）：
<div id="root"></div>

執行順序：
1. 瀏覽器下載這個最小的 HTML
2. 瀏覽器開始下載 JavaScript 包文件（bundle.js），其中包含 React 庫和應用程式的自定義代碼。
3. 瀏覽器下載完 JavaScript 文件後，開始執行其中的代碼，初始化 React 應用程式。
4. React 開始渲染應用程式的初始界面，將虛擬 DOM（Virtual DOM）轉換為實際的 DOM 並插入 HTML 中。
```
1. [瀏覽器請求] → 瀏覽器向服務器發出頁面請求
     ↓
2. [接收基礎 HTML] → 服務器返回基本的 HTML 結構，包含：
     - <div id="root"></div>
     - JS 檔案的引用（bundle.js）
     - CSS 檔案的引用
     ↓
3. [分析 HTML，下載資源] → 瀏覽器：
     - 解析 HTML 結構
     - 同時開始下載 JS/CSS 文件
     ↓
4. [執行 JavaScript] → 
     - 執行 React 相關代碼
     - 創建虛擬 DOM
     - 將虛擬 DOM 渲染到真實 DOM（getElementById("root")）
     ↓
5. [初始渲染完成] → 
     - 頁面已可見，但可能只有基礎結構或 loading 狀態

