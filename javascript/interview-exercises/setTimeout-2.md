這段代碼展示了一個常見的 JavaScript 閉包問題，通常用於考核對 JavaScript 執行上下文和作用域鏈的理解。
```javascript
for (var i = 0; i < 5; i++) {
    setTimeout(() => { 
        console.log(i); 
    }, 1000); 
}
```

### 基本概念

在 JavaScript 中，變數的作用域有兩種主要類型：**全域作用域** 和 **函數作用域**。`var` 變數的作用域是函數級別，而不是塊級別。這意味著在同一個函數內，無論變數是在什麼位置宣告的，它都可以在整個函數中使用。

```javascript
for (var i = 0; i < 5; i++) {
    setTimeout(() => { 
        console.log(i); 
    }, 1000); 
}
```
`setTimeout` 是一個非同步函數，它會在 1000 毫秒（1 秒）後執行回調函數。

#### 為什麼結果是五次 `5`？

1. **`setTimeout` 的非同步行為**：
   - `setTimeout` 是非同步的，它將[回調函數宏任務（Macrotask）]放到事件隊列中。
   - 當迴圈結束時，事件循環開始處理[回調函數宏任務（Macrotask）]，此時 `i` 已經是 `5`。

2. **執行順序**：
   - 迴圈結束時，所有的 `setTimeout` 回調函數都已被放入事件隊列中。
   - 當 1000 毫秒過去，事件循環開始執行這些回調函數，
   var 是[函數作用域] 變量共享，每次迭代實際上是在[更新同一個] i。`i` 已經是 `5`，所以會打印五次 `5`。
   let 是[塊級作用域]，每次迭代創建新的變量。


### 解決方法

可以使用 `let` 或 IIFE（立即執行函數表達式）來創建塊級作用域，使每次迭代有自己的 `i`。

#### 使用 `let`：
```javascript
for (let i = 0; i < 5; i++) {
    setTimeout(() => { 
        console.log(i); 
    }, 1000); 
}
```
`let` 創建了塊級作用域，確保每次迭代都有自己的變數 `i`。

#### 使用 IIFE：
```javascript
for (var i = 0; i < 5; i++) {
    (function(i) {
        setTimeout(() => { 
            console.log(i); 
        }, 1000);
    })(i);
}
```
- IIFE 創建了一個新的函數作用域，使每次迭代的 `i` 都在自己的作用域中。


### answer:
- * a. 為什麼結果會顯示 5 顯示五次？
- var 是函數作用域導致變量共享。 
- let 是塊作用域每次迭代創建新的變量
- 
- for 循環是一個同步操作
- 當 setTimeout 的回調執行時（即事件循環進入任務隊列的時候），for 已經結束，i 的值是 5（最後一次迭代後的值）。
- 每個 setTimeout 回調函數引用的都是同一個 i，因此在回調執行時，i 始終是最終的值 5。
- 
- 
- * b. 為什麼結果是⼀次顯⽰，⽽非間隔⼀秒地顯⽰？
- setTimeout 是將回調函數加入到 Macrotask 隊列不會阻塞主線程，並在指定時間後執行
- 看起來是同時輸出，但其實是幾乎瞬間連續輸出的
- 回調的執行非常快，並且所有回調在同一個事件循環階段中處理（因為它們都在 Macrotask 隊列中）。
- 瀏覽器或 Node.js 在執行這些回調時，輸出速度足夠快，人眼無法感知到明顯的間隔，從而看起來像是「一次性」輸出。