要實作 `random6(n)`，我們需要從 `1` 到 `n` 之間隨機選取 6 個不重複的數字。這可以用幾種不同的方法來完成，並且每種方法的時間與空間複雜度不同：

---

### **解法 1：使用 Set + 隨機數 (洗牌法)**
**邏輯：**
1. 使用 `Set` 來儲存隨機數，確保不重複。
2. 持續產生隨機數，直到 `Set` 的大小達到 6。

**程式碼：**
```js
function random6(n) {
    let set = new Set();
    while (set.size < 6) {
        set.add(Math.floor(Math.random() * n) + 1);
    }
    return [...set];
}
```

**時間複雜度：**  
- `O(6) = O(1)` 在理想情況下，每次隨機數生成都是獨立的。
- 但由於碰撞（重複數字）可能導致額外的嘗試，因此最差情況為 `O(6 * log n)`，但仍然是 **近似 O(1)**。

**空間複雜度：**  
- `O(6) = O(1)`，因為 Set 只存 6 個數。

---

### **解法 2：Fisher-Yates 洗牌 (陣列洗牌法)**
**邏輯：**
1. 先建立 `[1, 2, ..., n]` 陣列。
2. 使用 **Fisher-Yates 洗牌演算法** 來打亂陣列。
3. 取前 6 個數字。

**程式碼：**
```js
function random6(n) {
    let arr = Array.from({ length: n }, (_, i) => i + 1);
    for (let i = n - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr.slice(0, 6);
}
```

**時間複雜度：**  
- **O(n)**，因為 Fisher-Yates 需要 `O(n)` 時間來洗牌。

**空間複雜度：**  
- **O(n)**，因為需要存放整個 `arr` 陣列。

---

### **解法 3：隨機選取 + 交換**
**邏輯：**
1. 直接在 `[1, n]` 範圍內隨機選取 6 個數字，每選取一個數時，將其與最後一個可選範圍內的數交換，以確保不重複。
2. 這是一種 **類似洗牌但只進行前 6 步驟** 的方法。

**程式碼：**
```js
function random6(n) {
    let arr = Array.from({ length: n }, (_, i) => i + 1);
    for (let i = 0; i < 6; i++) {
        let j = Math.floor(Math.random() * (n - i)) + i;
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr.slice(0, 6);
}
```

**時間複雜度：**  
- **O(6) = O(1)**，因為我們只執行 6 次交換。

**空間複雜度：**  
- **O(n)**，因為需要存放整個 `arr` 陣列。

---

### **比較各種方法**
| 方法 | 時間複雜度 | 空間複雜度 | 備註 |
|------|----------|----------|------|
| **Set + 隨機數** | 近似 `O(1)` | `O(1)` | 可能有碰撞導致額外嘗試 |
| **Fisher-Yates 洗牌** | `O(n)` | `O(n)` | 先打亂整個陣列再取前 6 個 |
| **隨機選取 + 交換** | `O(1)` | `O(n)` | 只執行 6 次交換，效率最高 |

#### **最佳選擇**
如果 `n` 很大，例如 `n = 10^6`，那麼 **解法 3**（隨機選取 + 交換）是最好的，因為它的時間複雜度是 **O(1)**，並且可以保證不重複數字。